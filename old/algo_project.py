# -*- coding: utf-8 -*-
"""algo-project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xsWALm3xcNadgpJA2YxfWSdVunAZYsQ0
"""

import json
import networkx as nx
import matplotlib.pyplot as plt
import requests
import geopandas as gpd
from shapely.geometry import Polygon, Point, MultiPolygon, GeometryCollection, LineString
import pandas as pd
from shapely.wkt import loads
import math
import matplotlib.pyplot as plt
api_key = '5b3ce3597851110001cf6248a2a99fdd507247b7b125072bb1b8ebaa'
file = 'service-Stations-Bordeaux-1.3.geojson'

overpass_url = "http://overpass-api.de/api/interpreter"
# This query looks for nodes tagged as highway=services or highway=rest_area within a radius of 1000 meters
overpass_query = f"""
[out:json];
area[name = "France"];
(way["highway"~"services|rest_area"](around:60000,44.786422651838116,-0.594943707197586);>;);
out;
    """

response = requests.get(overpass_url, params={'data': overpass_query})

gdf = gpd.read_file(response.json())

def parse_geojson_nodes(geojson_file):
    with open(geojson_file, 'r') as file:
        data = json.load(file)
    nodes = {}
    for feature in data['features']:
        id = feature['properties']['id']
        coords = tuple(feature['geometry']['coordinates'])
        nodes[id] = coords
    return nodes

def get_motorway_distance(coord1, coord2, api_key):
    # Create the URL for the HTTP request
    url = f"https://api.openrouteservice.org/v2/directions/driving-car"
    params = {
        'api_key': api_key,
        'start': f"{coord1[0]},{coord1[1]}",  # OpenRouteService uses lng,lat
        'end': f"{coord2[0]},{coord2[1]}"
    }

    # Make the GET request to the OpenRouteService API
    response = requests.get(url, params=params)

    # Check if the request was successful
    if response.status_code == 200:
        # Parse the JSON response
        data = response.json()
        # Retrieve the distance from the response (distance is in meters)
        distance = data['features'][0]['properties']['segments'][0]['distance'] / 1000  # convert to km
        return distance
    else:
        # print(f"Error: {response.status_code}")
        return None

def get_adjacent_stations(coord, nodes, radius=60000):
    lat, lon = coord
    overpass_url = "http://overpass-api.de/api/interpreter"
    # This query looks for nodes tagged as highway=services or highway=rest_area within a radius of 1000 meters
    overpass_query = f"""
[out:json];
area[name = "France"];
(way["highway"~"services|rest_area"](around:60000,44.786422651838116,-0.594943707197586);>;);
out;
    """

    response = requests.get(overpass_url, params={'data': overpass_query})
    adjacent_stations = []
    if response.status_code == 200:
        data = response.json()
        # print(data)
        for element in data['elements']:
            # Assuming you want to exclude the service station at the given coordinates
            print(element)
            try:
                if element['lat'] != lat or element['lon'] != lon:
                    adjacent_stations.append(element['id'])


            except:
                id = element['nodes'][0]
                print(nodes[str(id)])



    else:
        print(f"Overpass API Error: {response.status_code}")

    return adjacent_stations

def create_edges(nodes):
    edges = []
    adjacent_nodes = []
    node_ids = list(nodes.keys())
    # print(node_ids)
    # print(get_adjacent_stations(nodes[node_ids[5]]))

    for i in range(len(node_ids)):

        adjacent_nodes = get_adjacent_stations(nodes[node_ids[i]], nodes)

        for j in range(len(adjacent_nodes)):

            distance = get_motorway_distance(nodes[node_ids[i]], nodes[adjacent_nodes[j]],'5b3ce3597851110001cf6248a2a99fdd507247b7b125072bb1b8ebaa')

            if distance != None and distance <= 20 :
                edges.append((node_ids[i], node_ids[j], distance))
    return edges

# Load nodes (service stations and rest areas)
all_nodes = parse_geojson_nodes(file)

# Create the graph
G = nx.Graph()
G.add_nodes_from(all_nodes.keys())

print(all_nodes)

edges = create_edges(all_nodes)
G.add_weighted_edges_from(edges)


# # Create a dictionary to map node IDs to their coordinates
# node_coordinates = {node_id: coords for node_id, coords in all_nodes.items()}


# # Get edge labels as a dictionary (edge: weight)
# edge_labels = {(u, v): d['weight'] for u, v, d in G.edges(data=True)}


# # Plot the graph with node labels as coordinates
# nx.draw(G, pos=node_coordinates, with_labels=True, node_color='skyblue', font_weight='bold', labels={k: str(v) for k, v in node_coordinates.items()})
# nx.draw_networkx_edge_labels(G, pos=node_coordinates, edge_labels=edge_labels)
# plt.show()

# # fw_distances = nx.floyd_warshall(G)

# # Convert the matrix to a NumPy array
shortest_paths_array = np.array(fw_distances)

# # Print the 2D array
print(shortest_paths_array)